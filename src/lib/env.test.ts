import { describe, expect, test } from "bun:test";
import { generateEnvHeader, jsonToEnv, parseEnvContent } from "./env";

describe("parseEnvContent", () => {
  test("parses basic KEY=value", () => {
    expect(parseEnvContent("FOO=bar")).toEqual({ FOO: "bar" });
  });

  test("parses multiple KEY=value pairs", () => {
    const content = `FOO=bar
BAZ=qux`;
    expect(parseEnvContent(content)).toEqual({ FOO: "bar", BAZ: "qux" });
  });

  test("parses double-quoted values", () => {
    expect(parseEnvContent('FOO="bar baz"')).toEqual({ FOO: "bar baz" });
  });

  test("parses single-quoted values", () => {
    expect(parseEnvContent("FOO='bar baz'")).toEqual({ FOO: "bar baz" });
  });

  test("preserves hash in double-quoted values", () => {
    expect(parseEnvContent('FOO="bar#baz"')).toEqual({ FOO: "bar#baz" });
  });

  test("preserves hash in single-quoted values", () => {
    expect(parseEnvContent("FOO='bar#baz'")).toEqual({ FOO: "bar#baz" });
  });

  test("removes inline comment from unquoted values", () => {
    expect(parseEnvContent("FOO=bar # this is a comment")).toEqual({ FOO: "bar" });
  });

  test("skips empty lines", () => {
    const content = `FOO=bar

BAZ=qux`;
    expect(parseEnvContent(content)).toEqual({ FOO: "bar", BAZ: "qux" });
  });

  test("skips comment lines", () => {
    const content = `# This is a comment
FOO=bar
# Another comment
BAZ=qux`;
    expect(parseEnvContent(content)).toEqual({ FOO: "bar", BAZ: "qux" });
  });

  test("skips lines without equal sign", () => {
    const content = `FOO=bar
invalid line
BAZ=qux`;
    expect(parseEnvContent(content)).toEqual({ FOO: "bar", BAZ: "qux" });
  });

  test("handles value with equal sign", () => {
    expect(parseEnvContent("FOO=bar=baz")).toEqual({ FOO: "bar=baz" });
  });

  test("trims whitespace around key and value", () => {
    expect(parseEnvContent("  FOO  =  bar  ")).toEqual({ FOO: "bar" });
  });

  test("handles empty value", () => {
    expect(parseEnvContent("FOO=")).toEqual({ FOO: "" });
  });

  test("returns empty object for empty content", () => {
    expect(parseEnvContent("")).toEqual({});
  });

  test("returns empty object for only comments", () => {
    const content = `# comment 1
# comment 2`;
    expect(parseEnvContent(content)).toEqual({});
  });
});

describe("jsonToEnv", () => {
  test("converts simple key-value pairs", () => {
    const result = jsonToEnv({ FOO: "bar", BAZ: "qux" });
    expect(result).toBe('FOO="bar"\nBAZ="qux"');
  });

  test("quotes values with spaces", () => {
    const result = jsonToEnv({ FOO: "bar baz" });
    expect(result).toBe('FOO="bar baz"');
  });

  test("quotes values with hash", () => {
    const result = jsonToEnv({ FOO: "bar#baz" });
    expect(result).toBe('FOO="bar#baz"');
  });

  test("escapes double quotes in values", () => {
    const result = jsonToEnv({ FOO: 'bar"baz' });
    expect(result).toBe('FOO="bar\\"baz"');
  });

  test("handles empty value", () => {
    const result = jsonToEnv({ FOO: "" });
    expect(result).toBe('FOO=""');
  });

  test("handles empty object", () => {
    const result = jsonToEnv({});
    expect(result).toBe("");
  });

  test("handles values with single quotes", () => {
    const result = jsonToEnv({ FOO: "bar'baz" });
    expect(result).toBe('FOO="bar\'baz"');
  });

  test("handles values with newlines", () => {
    const result = jsonToEnv({ FOO: "bar\nbaz" });
    expect(result).toBe('FOO="bar\nbaz"');
  });

  test("converts number values to string", () => {
    const result = jsonToEnv({ PORT: 3000, DEBUG: 1 });
    expect(result).toBe('PORT="3000"\nDEBUG="1"');
  });

  test("converts boolean values to string", () => {
    const result = jsonToEnv({ ENABLED: true, DISABLED: false });
    expect(result).toBe('ENABLED="true"\nDISABLED="false"');
  });

  test("converts null and undefined to string", () => {
    const result = jsonToEnv({ NULL_VAL: null, UNDEF_VAL: undefined });
    expect(result).toBe('NULL_VAL="null"\nUNDEF_VAL="undefined"');
  });

  test("converts object values to string", () => {
    const result = jsonToEnv({ OBJ: { nested: "value" } });
    expect(result).toBe('OBJ="[object Object]"');
  });
});

describe("generateEnvHeader", () => {
  test("generates header with secret name", () => {
    const result = generateEnvHeader("my-secret");
    expect(result).toBe("# Generated by e2sm\n# Source: my-secret");
  });

  test("handles secret name with special characters", () => {
    const result = generateEnvHeader("prod/api/secrets");
    expect(result).toBe("# Generated by e2sm\n# Source: prod/api/secrets");
  });
});
